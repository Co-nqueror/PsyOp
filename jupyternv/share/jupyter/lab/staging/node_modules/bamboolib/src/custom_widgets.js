var _ = require('underscore');
window.$ = window.jQuery = require('jquery');
require('jquery-ui-dist/jquery-ui.min.js');
require('style-loader!jquery-ui-dist/jquery-ui.min.css');

require('selectize');
require('style-loader!./selectize.bootstrap3.css');

var widgets = require('@jupyter-widgets/base');
var widgets_controls = require('@jupyter-widgets/controls');

require('style-loader!./bamboolib.css');


// create enterKey function as jQuery plugin
$.fn.enterKey = function (fnc) {
    return this.each(function () {
        $(this).keypress(function (ev) {
            var keycode = (ev.keyCode ? ev.keyCode : ev.which);
            if (keycode == '13') {
                fnc.call(this, ev);
            }
        })
    })
}

// This widget is a wrapping div that listens to click events and forwards them to Python
class BamClickableModel extends widgets_controls.BoxModel {
    defaults() {
        return _.extend(widgets_controls.BoxModel.prototype.defaults(), {
            _model_name: 'BamClickableModel',
            _view_name: 'BamClickableView',
            _model_module: 'bamboolib',
            _view_module: 'bamboolib',
        });
    }
}

class BamClickableView extends widgets_controls.BoxView {
    initialize(parameters) {
        super.initialize(parameters);

        this.$el.on("click", (event) => {
            var msg = {
                'type': 'on_click',
            };
            this.send(msg);
            event.stopPropagation()
        })
    }
}


// This widget provides a tab.
// Important: "tab" in this context only means the small header element that the user can click on and close. This does not include an outlet for tab content
class BamTabModel extends widgets_controls.BoxModel {
    defaults() {
        return _.extend(widgets_controls.BoxModel.prototype.defaults(), {
            _model_name: 'BamTabModel',
            _view_name: 'BamTabView',
            _model_module: 'bamboolib',
            _view_module: 'bamboolib',
        });
    }
}

class BamTabView extends widgets_controls.BoxView {

    update() {
        // this method is automatically called by ipywidgets once the model changes
        this.title_node.textContent = this.model.get("title")
    }

    initialize(parameters) {
        super.initialize(parameters);

        this.title = this.model.get("title")

        this.title_node = this.$el[0].appendChild($(`<span>${this.title}</span>`)[0])

        this.$el.on("click", (event) => {
            var msg = {
                'type': 'on_click',
            };
            this.send(msg);
        })

        if (this.model.get("closable")) {

            this.close_button_node = this.$el[0].appendChild($(
                `<div class="bamboolib-tab-close-button">
                    <div class="bamboolib-crossline bamboolib-crossline-1">
                        <div class="bamboolib-crossline bamboolib-crossline-2"></div>
                    </div>
                </div>`)[0])
            $(this.close_button_node).on("click", (event) => {
                var msg = {
                    'type': 'on_close',
                };
                this.send(msg);
                event.stopPropagation()  // make sure that the normal on_click is not also triggered
            })
        }
    }
}


// This widget provides the header row for the bamboolib glimpse that shows the names of the columns
class BamGlimpseHeaderModel extends widgets_controls.BoxModel {
    defaults() {
        return _.extend(widgets_controls.BoxModel.prototype.defaults(), {
            _model_name: 'BamGlimpseHeaderModel',
            _view_name: 'BamGlimpseHeaderView',
            _model_module: 'bamboolib',
            _view_module: 'bamboolib',
        });
    }
}

class BamGlimpseHeaderView extends widgets_controls.BoxView {

    initialize(parameters) {
        super.initialize(parameters);

        this.$el[0].appendChild($(`<div class="bamboolib-glimpse-column-name"><b>Column</b></div>`)[0])
        this.$el[0].appendChild($(`<div class="bamboolib-glimpse-dtype"><b>Data type</b></div>`)[0])
        this.$el[0].appendChild($(`<div class="bamboolib-glimpse-unique"><b>Unique values</b></div>`)[0])
        this.$el[0].appendChild($(`<div class="bamboolib-glimpse-missing"><b>Missing values</b></div>`)[0])

    }
}

// This widget provides a single content row for the bamboolib glimpse
// which contains statistical information like count of missing values for a given column
// The row is meant to be updated because the statistics might be calculated based on a sample if the dataset is too big
class BamGlimpseRowModel extends widgets_controls.BoxModel {
    defaults() {
        return _.extend(widgets_controls.BoxModel.prototype.defaults(), {
            _model_name: 'BamGlimpseRowModel',
            _view_name: 'BamGlimpseRowView',
            _model_module: 'bamboolib',
            _view_module: 'bamboolib',
        });
    }
}

class BamGlimpseRowView extends widgets_controls.BoxView {

    maybeDestroyTooltip(node) {
        // If a node gets replaced while the user is currently hovering (and thus a tooltip is shown)
        // then the tooltip will stay forever and never get deleted.
        // As a fix, we (potentially) delete the tooltip AFTER the node was replaced
        try {
            $(node).tooltip("destroy")
        } catch (e) {
            // an error gets thrown if no tooltip is available
        }
    }

    update() {
        this.column_name = this.model.get("name")
        this.dtype = this.model.get("dtype")
        this.unique_count = this.model.get("unique_count")
        this.unique_percent = this.model.get("unique_percent")
        this.missings_count = this.model.get("missings_count")
        this.missings_percent = this.model.get("missings_percent")
        this.loading = this.model.get("loading")
        this.sample_size = this.model.get("sample_size")

        var new_node // initialize variable before assigning to it below

        var loading_disclaimer = ""
        if (this.loading) {
            loading_disclaimer = `<br><br>This result is based on a <b>random sample of ${this.sample_size} rows</b>. We are still calculating the results for the full dataset in the background.`
            new_node = $(`<div class="bamboolib-glimpse-loader"><div class='bamboolib-load-spinner'></div></div>`)[0]
        } else {
            new_node = $(`<div></div>`)[0]
        }
        this.loading_node.replaceWith(new_node)
        this.loading_node = new_node

        new_node = $(`<div class="bamboolib-glimpse-column-name">${this.column_name}</div>`)[0]
        this.column_name_node.replaceWith(new_node)
        this.column_name_node = new_node

        new_node = $(`<div class="bamboolib-glimpse-dtype">${this.dtype}</div>`)[0]
        this.dtype_node.replaceWith(new_node)
        this.dtype_node = new_node

        new_node = $(`
            <div
                title="Unique values: ${this.unique_count} - ${this.unique_percent}${loading_disclaimer}"
                class="bamboolib-glimpse-unique bamboolib-tooltip"
                style="background: linear-gradient(90deg, #A1D8FF ${this.unique_percent}, transparent 0%);"
                >
            ${this.unique_count}
            </div>`)[0]
        this.uniques_node.replaceWith(new_node)
        this.maybeDestroyTooltip(this.uniques_node)
        this.uniques_node = new_node

        var missings_text = (this.missings_count == "0") ? "0" : `${this.missings_count} - ${this.missings_percent}`
        new_node = $(`
            <div
                title="Missing values: ${this.missings_count} - ${this.missings_percent}${loading_disclaimer}"
                class="bamboolib-glimpse-missing bamboolib-tooltip"
                style="
                    background: linear-gradient(90deg, #d65f5f ${this.missings_percent}, transparent 0%);
                    background-color: #5fba7d;"
                >
            ${missings_text}
            </div>`)[0]
        this.missings_node.replaceWith(new_node)
        this.maybeDestroyTooltip(this.missings_node)
        this.missings_node = new_node

        $(function () {
            // function needs to be executed after the elements have been rendered
            $(".bamboolib-tooltip").tooltip(
                {
                    content: function () {
                        // enables to render HTML within the tooltip
                        return $(this).prop('title');
                    },
                    hide: false,
                    show: false,
                    position: { my: "left top+3", at: "left bottom", collision: "flipfit" },
                })
        })
    }

    initialize(parameters) {
        super.initialize(parameters);

        this.column_name_node = this.$el[0].appendChild($(`<div></div>`)[0])
        this.dtype_node = this.$el[0].appendChild($(`<div></div>`)[0])
        this.uniques_node = this.$el[0].appendChild($(`<div></div>`)[0])
        this.missings_node = this.$el[0].appendChild($(`<div></div>`)[0])
        this.loading_node = this.$el[0].appendChild($(`<div></div>`)[0])

        this.update()

        this.$el.on("click", (event) => {
            var msg = {
                'type': 'on_click',
            };
            this.send(msg);
        })
    }
}


// This widget provides a div that does not propagate events outside of its scope if it is focused.
// This solves the problem that users are sometimes accidentally interacting with Jupyter shortcuts when trying to type within our UI.
class BamFocusBoxModel extends widgets_controls.BoxModel {
    defaults() {
        return _.extend(widgets_controls.BoxModel.prototype.defaults(), {
            _model_name: 'BamFocusBoxModel',
            _view_name: 'BamFocusBoxView',
            _model_module: 'bamboolib',
            _view_module: 'bamboolib',
        });
    }
}

class BamFocusBoxView extends widgets_controls.BoxView {
    initialize(parameters) {
        super.initialize(parameters);

        // enable the div to be focusable in order to be able to catch the keyboard events
        this.$el[0].tabIndex = 0

        // Some input if we want to control the behavior of what gets selected after a tab:
        // we might create a loop, eg selecting the first element in a row again
        // we might not allow to focus past a certain element
        // https://stackoverflow.com/questions/7208161/focus-next-element-in-tab-index

        // dont propagate events to jupyter because this will interact with the editor
        this.$el.on("keydown", (event) => {
                event.stopPropagation()
            })
            .on("keyup", (event) => {
                event.stopPropagation()
            })
            .on("keypress", (event) => {
                event.stopPropagation()
            })
            .on("click", (event) => {
                event.stopPropagation()
            })
    }
}

// This widget provides a means to set the focus. Not more, not less.
class BamFocusPointModel extends widgets_controls.BoxModel {
    defaults() {
        return _.extend(widgets_controls.BoxModel.prototype.defaults(), {
            _model_name: 'BamFocusPointModel',
            _view_name: 'BamFocusPointView',

            _model_module: 'bamboolib',
            _view_module: 'bamboolib',
        });
    }
}

class BamFocusPointView extends widgets_controls.BoxView {
    initialize(parameters) {
        super.initialize(parameters);
        // set tabIndex so that the div becomes focusable
        this.$el[0].tabIndex = -1
        this.$el.focus()

        this.model.on('msg:custom', this.focus, this);

        // when trying focus from the Chrome Debug tools, we need to run setTimeout in the console and then click in the main window to observe the effect:
        // window.bam_focus_point_view = this  // needed setup code within the class
        // setTimeout(function(){bam_focus_point_view.$el.focus()}, 1000)  // code that is run from the debug console
    }
    focus(){
        this.$el.focus()
    }
}


// This widget provides a customized selectize input
// See more infos about the general selectize API at https://github.com/selectize/selectize.js
// In addition, some of the behavior is changed to suit our needs, e.g.
// - We changed the appearance of options
// - We added an item that prompts users to propose new features if there are no good search results
// The following adjustments are made for controlling bamboolib with keyboard only:
// - The behavior of the TAB key depends on the state of the widget e.g. Single or Multiselect and if the user is currently searching
// - We added the notion of a "soft value" that is deleted when the user starts typing
class BamSelectizeModel extends widgets.DOMWidgetModel {
    defaults() {
        return _.extend(widgets.DOMWidgetModel.prototype.defaults(), {
            _model_name: 'BamSelectizeModel',
            _view_name: 'BamSelectizeView',
            _model_module: 'bamboolib',
            _view_module: 'bamboolib',
            value: '',
        });
    }
}

class BamSelectizeView extends widgets.DOMWidgetView {
    render() {
        this.model.on('msg:custom', this.handle_msg, this);
        this.listenTo(this.model, 'change:itemsSelectize', () => this._updateItemsSelectize(this.model.get("itemsSelectize")))
        this.listenTo(this.model, 'change:optionsSelectize', () => this.render())
        this.ignore_next_update = false
        $(this.$el[0]).empty()  // maybe reset the element

        // type of input is determined implicilty by selectize via the maxItems attribute
        this.input = $(`<input class="bamboolib-selectize" type="text">`).appendTo(this.$el);

        var optionsSelectize = this.model.get("optionsSelectize")
        var itemsSelectize = this.model.get("itemsSelectize")
        var maxItems = this.model.get("_max_items")

        var isDropdown = maxItems == 1
        this.isMultiSelect = !isDropdown

        var placeholder = this.model.get("placeholder")
        placeholder += "  "  // trailing whitespace in order to prevent the bug of cutting the string

        // ENTER selects search in selectize, TAB changes to next element
        // dropdowns can also be selected (and simultaneously switched away from) with TAB
        var selectOnTab = this.model.get("select_on_tab") || isDropdown

        this.userIsSearching = false

        this.input.selectize({
            create: false,  // user can add/create new items
            placeholder: placeholder,
            options: optionsSelectize,
            items: itemsSelectize,
            maxItems: maxItems,
            searchField: ['value', 'description'],
            selectOnTab: selectOnTab,
            render: {
                // Defines the appearance of displayed option
                option: function (data, escape) {
                    if (data.description === undefined || data.description === '') {
                        return '<div class="option">' + escape(data.value) + '</div>'
                    } else {
                        return '<div class="option">' +
                            '<span class="value">' + escape(data.value) + '</span>' +
                            '<span class="description">' + escape(data.description) + '</span>' +
                            '</div>';
                    }
                },
                // Defines the appearance of a selected item
                item: function (data, escape) {
                    return '<div class="item">' + escape(data.value) + '</div>';
                }
            },
            onChange: (value) => { this.onChange(value) },
            onFocus: () => {
                if (isDropdown) {
                    var _is_soft_value = this.model.get("_is_soft_value")
                    if (_is_soft_value) {
                        // clear selection so that the users can type immediately
                        this.selectize.clear(true)
                        this.model.set('_is_soft_value', false)
                        this.touch()
                    }
                }
            },
            onType: (str) => {
                if (str == '') {
                    this.userIsSearching = false
                } else {
                    this.userIsSearching = true
                }
                this.updateSelectOnTab()
            },
            onItemAdd: () => {
                this.userIsSearching = false
                this.updateSelectOnTab()
            },
            score: function (search) {
                var score = this.getScoreFunction(search);
                return (item) => {
                    // Ensures feature requests always show up last
                    if (item.text == "Not found what you're looking for?") {
                        return 0.0001;
                    } else {
                        return score(item)
                    }
                }
            }
        });
        this.selectize = this.input[0].selectize
        this.preventEventPropagation()

        var enabled = this.model.get("enabled")
        if (!enabled) {
            this.selectize.disable()
        }

        var focus_after_init = this.model.get("focus_after_init")
        var _did_focus_after_init = this.model.get("_did_focus_after_init")
        if (focus_after_init && !_did_focus_after_init) {
            this.selectize.focus()
            this.model.set('_did_focus_after_init', true)
            this.touch()
        }
    }

    updateSelectOnTab() {
        // Sometimes, the user shall be able to select an item when hitting TAB key
        // This method updates the selectize settings based on the current state

        if (this.model.get("select_on_tab")) {
            // don't change the settings
        } else if (this.isMultiSelect) {
            this.selectize.settings.selectOnTab = this.userIsSearching
        }
    }

    handle_msg(msg) {
        if (msg.type === 'focus') {
            this.selectize.focus()
        }
        if (msg.type === 'rerender') {
            this.render()
        }
    }

    preventEventPropagation() {
        this.selectize.$control_input[0].addEventListener("keydown", (event) => {
            // dont propagate enter or tab event to CodeMirror because this will focus the editor
            // and this might lead to a scroll event by CodeMirror.
            // there are also keypress and keyup events, but CodeMirror is currently listening to keydown
            event.stopPropagation();
        });
    }

    onChange(value) {
        this.ignore_next_update = true

        var itemsSelectize = this.selectize.items

        var message = {
            'type': 'on_change',
            'itemsSelectize': itemsSelectize
        }
        this.send(message);
    }

    _updateItemsSelectize(itemsSelectize) {
        if (this.ignore_next_update) {
            this.ignore_next_update = false
        } else {
            this.selectize.clear(true)
            this.selectize.setValue(itemsSelectize, true)
        }
    }
}


// We had to create our own TextInput widget because when trying to inherit from widgets_controls.TextModel we could not make the focus on the input work
class BamTextModel extends widgets.DOMWidgetModel {
    defaults() {
        return _.extend(widgets.DOMWidgetModel.prototype.defaults(), {
            _model_name: 'BamTextModel',
            _view_name: 'BamTextView',
            _model_module: 'bamboolib',
            _view_module: 'bamboolib',
            value: '',
        });
    }
}

class BamTextView extends widgets.DOMWidgetView {
    update_value(value) {
        this.input[0].value = value
    }

    update_model() {
        this.model.set('value', this.input[0].value)
        this.touch()
    }

    render() {
        this.listenTo(this.model, 'change:value', (model, value, options) => {
            this.update_value(value)
        });

        this.input = $(`<input type="text" style="width: 100%; line-height: inherit; font-size: inherit; box-sizing: inherit;" autocomplete="new-password"></input>`).appendTo(this.$el);
        this.update_value(this.model.get("value"))
        this.input[0].placeholder = this.model.get("placeholder")

        this.input
            .ready(() => {
                var focus_after_init = this.model.get("focus_after_init")
                var _did_focus_after_init = this.model.get("_did_focus_after_init")
                if (focus_after_init && !_did_focus_after_init) {
                    this.input[0].focus()
                    this.model.set('_did_focus_after_init', true)
                    this.touch()
                }
            })
            .enterKey(() => {
                var msg = {
                    'type': 'on_press_enter',
                };
                this.send(msg);
            })
            .on("input", (event) => {
                // before, we had the problem, that we did the update but the input.value was not set yet
                // input.value is only guaranteed to be set after on:input
                // thus, we should not use keypress or others. They all have problems
                // also, the order is: keydown, keypress, keyup
                // See the following discussion:
                // https://stackoverflow.com/questions/8795283/jquery-get-input-value-after-keypress
                this.update_model()
            })
    }
}


// This widget inspects some attributes from the browser and sends them to Python, e.g.
// - it reads or creates a unique client_id from/to localStorage
// - it gathers information about the window.location
// The information is used on the Python side mainly for auth purposes
class BamBrowserCheckModel extends widgets.DOMWidgetModel {
    defaults() {
        return _.extend(widgets.DOMWidgetModel.prototype.defaults(), {
            _model_name: 'BamBrowserCheckModel',
            _view_name: 'BamBrowserCheckView',
            _model_module: 'bamboolib',
            _view_module: 'bamboolib',
            value: '',
        });
    }
}


class BamBrowserCheckView extends widgets.DOMWidgetView {
    render() {
        try {
            var client_id = localStorage.getItem('bamboolib_client_id')
            if (client_id == null) {
                // See the following discussion on how to create a UUID
                // https://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid/44078785#44078785
                // We chose a light-weight way that will be sufficient for our use case
                client_id = Date.now().toString(36) + Math.random().toString(36).substring(2)
                localStorage.setItem('bamboolib_client_id', client_id)
            }

            var msg = {
                "bamboolib_client_id": client_id,
                "window.location.href": window.location.href,
                "window.location.hostname": window.location.hostname,
                "window.location.pathname": window.location.pathname,
                "window.location.protocol": window.location.protocol,
            };
        } catch (e) {
            var msg = {}
        }
        this.send(msg);
    }
}

// This widget creates our own Button but uses a different CSS class
class ButtonModel extends widgets_controls.ButtonModel {
    defaults() {
        return _.extend(widgets_controls.ButtonModel.prototype.defaults(), {
            _model_name: 'ButtonModel',
            _view_name: 'ButtonView',
            _model_module: 'bamboolib',
            _view_module: 'bamboolib',
        });
    }
}

class ButtonView extends widgets_controls.ButtonView {
    render() {
        // this code is similar to ipywidgets.Button. The difference is that we changed the css class
        this.listenTo(this.model, 'change:button_style', this.update_button_style);
        this.el.classList.add('bamboolib-base-button');
        this.set_button_style();
        this.update();
    }
}

// This widget provides a button that copies a string to the clipboard of the user upon click
class BamCopyButtonModel extends ButtonModel {
    defaults() {
        return _.extend(ButtonModel.prototype.defaults(), {
            _model_name: 'BamCopyButtonModel',
            _view_name: 'BamCopyButtonView',
            _model_module: 'bamboolib',
            _view_module: 'bamboolib',
            copy_string: '',
        });
    }
}

class BamCopyButtonView extends ButtonView {
    update() {
        // ATTENTION: the update method is called after the first render
        //            AND after all model changes
        // during the update method of widgets.ButtonView the button gets restored
        // thus, the textarea element gets deleted and we need to restore it
        // This is also the reason, why the textarea element is created here (again and again)
        // and not only once in render

        super.update()

        this.textarea = $(`<textarea tabindex="-1"></textarea>`).appendTo(this.$el)
        this.textarea[0].value = this.model.get("copy_string")
    }

    _handle_click(event) {
        this.textarea[0].select()
        document.execCommand("copy")
        super._handle_click(event)
    }
}


// This widget provides a button that contains an SVG icon/graphic
class SVGButtonModel extends ButtonModel {
    defaults() {
        return _.extend(ButtonModel.prototype.defaults(), {
            _model_name: 'SVGButtonModel',
            _view_name: 'SVGButtonView',
            _model_module: 'bamboolib',
            _view_module: 'bamboolib',
            path: '',
            svg_size: '12',
            view_box: '',
        });
    }
}

class SVGButtonView extends ButtonView {
    render() {
        var xmlns = "http://www.w3.org/2000/svg";
        var svg = document.createElementNS(xmlns, "svg");
        svg.setAttributeNS(null, "viewBox", this.model.get("view_box"));
        svg.setAttributeNS(null, "width", this.model.get("svg_size"));
        svg.innerHTML = '<path d="' + this.model.get("path") + '"></path>';
        this.el.appendChild(svg);
        this.update(); // Set defaults.
    }
}

class BamTracebackOutputModel extends widgets.DOMWidgetModel {
    defaults() {
        return _.extend(widgets.DOMWidgetModel.prototype.defaults(), {
            _model_name: 'BamTracebackOutputModel',
            _view_name: 'BamTracebackOutputView',
            _model_module: 'bamboolib',
            _view_module: 'bamboolib',
            content: ''
        });
    }
}

class BamTracebackOutputView extends widgets.DOMWidgetView {
    _rerender_output(){
        // console.log("_rerender_output BamTracebackOutputView")
        this._reset_output()
        $(`<div class="output_text output_stream output_stderr" style="background: #fdd" dir="auto">
                <pre>${this.model.get('content')}</pre>
            </div>`).appendTo(this.$el);
    }

    _reset_output() {
        $(this.$el[0]).empty()
    }

    render() {
        this._rerender_output()
    }

    update() {
        this._rerender_output()
    }
}


// This widget provides a textarea that provides autocompletion for Python code
// The auto-completions are calculated on the Python side and sent to the widget to be displayed
class BamAutocompleteTextModel extends widgets.DOMWidgetModel {
    defaults() {
        return _.extend(widgets.DOMWidgetModel.prototype.defaults(), {
            _model_name: 'BamAutocompleteTextModel',
            _view_name: 'BamAutocompleteTextView',
            _model_module: 'bamboolib',
            _view_module: 'bamboolib',
            value: ''
        });
    }
}

class BamAutocompleteTextView extends widgets.DOMWidgetView {

    handle_msg(msg) {
        if (msg.type === 'completion') {
            if (typeof this.response !== 'undefined') {
                this.response(msg.completions)
            }
        }
    }

    update_value() {
        this.input[0].value = this.model.get("value")
    }

    update_model() {
        this.model.set('value', this.input[0].value);
        this.touch()
    }

    cursor_is_at_single_position(element) {
        return element.selectionStart == element.selectionEnd
    }

    maybe_complete(element, start_string, end_string) {
        if (this.cursor_is_at_single_position(element)) {
            var cursor_position = element.selectionEnd
            var before_cursor = this.old_input_state["text_before_cursor"]
            var after_cursor = this.old_input_state["text_after_cursor"]

            if (element.value === before_cursor + start_string + after_cursor) {
                element.value = before_cursor + start_string + end_string + after_cursor
                element.setSelectionRange(cursor_position, cursor_position);
            }
        }
    }

    save_input_state(element) {
        var cursor_position = element.selectionEnd
        var before_cursor = element.value.substring(0, cursor_position)
        var after_cursor = element.value.substring(cursor_position)
        this.old_input_state = {
            "text_before_cursor": before_cursor,
            "text_after_cursor": after_cursor,
        }
    }

    render() {
        this.model.on('msg:custom', this.handle_msg, this);
        this.listenTo(this.model, 'change:value', (model, value, options) => {
            this.update_value();
        });

        this.input = $(`<textarea type="text"
                            id="bamboolib-complete"
                            class="bamboolib-input widget-textarea"
                            placeholder="${this.model.get('placeholder')}"
                            style="margin-left: 2px;
                                margin-top:${this.model.get('margin_top')}px;
                                width: 99%;
                                font-family: monospace;
                                line-height: inherit;
                                font-size: inherit;
                                box-sizing: inherit;
                                resize: vertical;"
                            rows="${this.model.get('nrows')}"
                        ></textarea>`)
            .appendTo(this.$el);
        this.update_value()

        this.old_input_state = {
            "text_before_cursor": "",
            "text_after_cursor": "",
        }

        this.input
            .ready(() => {
                let focus_after_init = this.model.get("focus_after_init");
                if (focus_after_init) {
                    this.input[0].focus()
                }
            })
            .on("keypress", function (event) {
                // don't navigate away from the field on tab when selecting an item
                if (event.keyCode === $.ui.keyCode.TAB &&
                    $(this).autocomplete("instance").menu.active) {
                    event.preventDefault();
                }
            })
            .enterKey((event) => {
                event.preventDefault();
                var msg = {
                    'type': 'on_press_enter',
                };
                this.send(msg);
            })
            .on("keyup", (event) => {
                var input = this.input[0]
                this.maybe_complete(input, "(", ")")
                this.maybe_complete(input, "[", "]")
                this.maybe_complete(input, "{", "}")
                this.maybe_complete(input, "'", "'")
                this.maybe_complete(input, '"', '"')
                this.save_input_state(input)
                this.update_model()
            })
            .on("input", (event) => {
                // Open question: is this only triggered by user input but not when we change input.value programmatically?
                this.update_model()
            })
            .autocomplete({
                minLength: 0,
                delay: 10,  // perceived as real time
                autoFocus: true,
                source: (request, response) => {
                    var msg = {
                        'type': 'completion_request',
                        'input': request.term,
                        'cursor_position': this.input[0].selectionEnd,
                    };
                    this.send(msg);

                    this.response = response
                },
                focus: function () {
                    // prevent value inserted on focus
                    return false;
                },
                select: (event, ui) => {
                    var input = this.input[0]
                    var old_input = input.value
                    var old_cursor_position = input.selectionEnd

                    var before_cursor = old_input.substring(0, old_cursor_position)
                    var after_cursor = old_input.substring(old_cursor_position)

                    var completion = ui.item.completion

                    var new_value = before_cursor + completion + after_cursor
                    this.input[0].value = new_value
                    var new_cursor_position = old_cursor_position + completion.length
                    input.setSelectionRange(new_cursor_position, new_cursor_position)

                    this.update_model()
                    this.save_input_state(input)

                    event.preventDefault()

                    return false;
                }
            });
    }
}

class BamCodeOutputModel extends widgets.DOMWidgetModel {
    defaults() {
        return _.extend(widgets.DOMWidgetModel.prototype.defaults(), {
            _model_name: 'BamCodeOutputModel',
            _view_name: 'BamCodeOutputView',
            _model_module: 'bamboolib',
            _view_module: 'bamboolib',
            _code_html: ''
        });
    }
}

class BamCodeOutputView extends widgets.DOMWidgetView {
    rerender_output(){
        this.reset_output()
        $(this.model.get('_code_html')).appendTo(this.$el);
    }

    reset_output() { $(this.$el[0]).empty() }

    render() { this.rerender_output() }

    update() { this.rerender_output() }
}

class BamTableOutputModel extends widgets.DOMWidgetModel {
    defaults() {
        return _.extend(widgets.DOMWidgetModel.prototype.defaults(), {
            _model_name: 'BamTableOutputModel',
            _view_name: 'BamTableOutputView',
            _model_module: 'bamboolib',
            _view_module: 'bamboolib',
            _df_html: ''
        });
    }
}

class BamTableOutputView extends widgets.DOMWidgetView {
    rerender_output(){
        this.reset_output()
        $(`<div class='rendered_html'>${this.model.get('_df_html')}</div>`).appendTo(this.$el);
    }

    reset_output() { $(this.$el[0]).empty() }

    render() { this.rerender_output() }

    update() { this.rerender_output() }
}

module.exports = {
    BamAutocompleteTextModel: BamAutocompleteTextModel,
    BamAutocompleteTextView: BamAutocompleteTextView,
    BamBrowserCheckModel: BamBrowserCheckModel,
    BamBrowserCheckView: BamBrowserCheckView,
    BamClickableModel: BamClickableModel,
    BamClickableView: BamClickableView,
    BamCodeOutputModel: BamCodeOutputModel,
    BamCodeOutputView: BamCodeOutputView,
    BamCopyButtonModel: BamCopyButtonModel,
    BamCopyButtonView: BamCopyButtonView,
    BamGlimpseHeaderModel: BamGlimpseHeaderModel,
    BamGlimpseHeaderView: BamGlimpseHeaderView,
    BamGlimpseRowModel: BamGlimpseRowModel,
    BamGlimpseRowView: BamGlimpseRowView,
    BamFocusBoxModel: BamFocusBoxModel,
    BamFocusBoxView: BamFocusBoxView,
    BamFocusPointModel: BamFocusPointModel,
    BamFocusPointView: BamFocusPointView,
    BamSelectizeModel: BamSelectizeModel,
    BamSelectizeView: BamSelectizeView,
    BamTableOutputModel: BamTableOutputModel,
    BamTableOutputView: BamTableOutputView,
    BamTabModel: BamTabModel,
    BamTabView: BamTabView,
    BamTextModel: BamTextModel,
    BamTextView: BamTextView,
    BamTracebackOutputModel: BamTracebackOutputModel,
    BamTracebackOutputView: BamTracebackOutputView,
    ButtonModel: ButtonModel,
    ButtonView: ButtonView,
    SVGButtonModel: SVGButtonModel,
    SVGButtonView: SVGButtonView,
};
