var _ = require('underscore');
window.$ = window.jQuery = require('jquery');

require('slickgrid-qgrid/slick.core.js');
require('slickgrid-qgrid/lib/jquery.event.drag-2.3.0.js');
require('slickgrid-qgrid/plugins/slick.rowselectionmodel.js');
require('slickgrid-qgrid/plugins/slick.checkboxselectcolumn.js');
require('slickgrid-qgrid/slick.dataview.js');
require('slickgrid-qgrid/slick.grid.js');
require('slickgrid-qgrid/slick.editors.js');
require('style-loader!slickgrid-qgrid/slick.grid.css');
require('style-loader!slickgrid-qgrid/slick-default-theme.css');

var widgets = require('@jupyter-widgets/base');

var dtype_button = require('./qgrid.dtype_button.js');
require('./slick.autocolumnsize.js');

require('style-loader!./qgrid.css');


var code_export = require('./code_export.js')
code_export.CodeExporter.maybeSetupForNotebook()


// This widget provides the grid for displaying DataFrames
// The code is inlined from the original qgrid library https://github.com/quantopian/qgrid
// Apache License 2.0, Copyright 2018 Quantopian, Inc.

// In contrast to the original qgrid widget:
// - it is not possible to alter individual cell values
// - the click on the column header triggers an event
// - there is no filter option for columns (which also provides a filter overlay)
// - the grid listens to special bamboolib callbacks
// - there is a plugin for resizing column widths
class BamGridModel extends widgets.DOMWidgetModel {
    defaults() {
        return _.extend(widgets.DOMWidgetModel.prototype.defaults(), {
            _model_name: 'BamGridModel',
            _view_name: 'BamGridView',
            _model_module: 'bamboolib',
            _view_module: 'bamboolib',
            _df_json: '',
            _columns: {}
        });
    }
}


class BamGridView extends widgets.DOMWidgetView {
    render() {
        this.model.on('msg:custom', this.handle_msg, this);
        this.initialize_qgrid();

        this.initializeTextSelectionListener()

        this.send({ 'type': 'bam_grid_rendered' });
    }

    initializeTextSelectionListener() {
        // When the user selects some text in a cell with the mouse, we trigger a callback that notifies Python

        // Input on how to make this work:
        // https://stackoverflow.com/questions/5669448/get-selected-texts-html-in-div
        // https://developer.mozilla.org/en-US/docs/Web/API/Selection
        // https://api.jquery.com/mouseup/

        $(this.$el).bind("mouseup", (event) => {
            var target_is_slick_cell = event.target.classList[0] === "slick-cell"

            if (target_is_slick_cell) {
                var selection = document.getSelection()
                var in_slick_cell = selection.focusNode.parentNode.classList[0] === "slick-cell"
                var single_cell = selection.anchorNode == selection.focusNode
                var is_range = !selection.isCollapsed

                if (in_slick_cell && is_range && single_cell) {
                    var column_index = event.target.classList[1].substring(1)
                    var selected_text = selection.toString()

                    var msg = {
                        'type': 'bam_cell_text_selection',
                        'column_index': column_index,
                        'selected_text': selected_text,
                    };
                    this.send(msg);
                }
            }
        });
    }

    maybeAdjustInitialUserCode(code) {
        // This function receives the initial_user_code and maybe removes the last line if it seems to be the name of the dataframe
        // This helps to make the code export more dense

        code = code.split("\n")

        if (code.length == 1) {
            // only the dataframe name is in the Jupyter cell and thus, we can strip it (and return no code)
            return ""
        }

        let last_line = code[code.length - 1]
        let last_line_is_comment = last_line.trim().startsWith("#")
        let last_line_contains_semicolon = last_line.search(";") != -1

        if (last_line_is_comment || last_line_contains_semicolon) {
            // don't remove the last line because it does not seem to be only the name of the dataframe
        } else {
            // otherwise, we assume the last line to be the name of the dataframe as usually should be the case
            // and thus, we also delete this from the initial_user_code
            code.pop();
        }
        return code.join("\n") + "\n";
    }

    updateLiveCodeExport(code_export, initial_user_code) {
        // For updating the live code export, it is important to know and persist the initial_user_code
        // js cannot savely store the initial user code because the widget might be rerendered
        // e.g. during toggle of show static UI or bamboolib UI and thus we cannot safely determine the first time the function is called
        // Thus, we need to save initial_user_code in the python df_manager state. Upon initialization, the initial_user_code is an empty string.
        // This is also the way how we know if the JS function is called the first time (and if we need to determine and persist the initial_user_code)

        if (initial_user_code == "") {  // this is the first code export because the initial_user_code cannot be empty
            // Therefore, we need to let the Python side know about the initial_user_code so that it can be persisted
            initial_user_code = this.getCodeOfParentCell()
            var msg = {
                'type': 'bam_initial_user_code',
                'initial_user_code': initial_user_code,
            }
            this.send(msg)
        }

        var new_cell_value = ""
        if (code_export == "") {
            new_cell_value = initial_user_code
        } else {
            let adjusted_initial_user_code = this.maybeAdjustInitialUserCode(initial_user_code)
            new_cell_value = adjusted_initial_user_code + code_export
        }
        this.setCodeOfParentCell(new_cell_value)
    }

    setCodeOfParentCell(new_code) {
        code_export.CodeExporter.setValue(this.$el, new_code)
    }

    getCodeOfParentCell() {
        var old_code = code_export.CodeExporter.getValue(this.$el)
        return old_code
    }

    /**
     * Main entry point for drawing the widget,
     * including toolbar buttons if necessary.
     */
    initialize_qgrid() {
        this.$el.empty();
        if (!this.$el.hasClass('q-grid-container')) {
            this.$el.addClass('q-grid-container');
        }
        this.initialize_toolbar();
        this.initialize_slick_grid();
    }

    initialize_toolbar() {
        if (!this.model.get('show_toolbar')) {
            this.$el.removeClass('show-toolbar');
        } else {
            this.$el.addClass('show-toolbar');
        }

        if (this.toolbar) {
            return;
        }

        this.toolbar = $("<div class='q-grid-toolbar'>").appendTo(this.$el);

        let append_btn = (btn_info) => {
            return $(`
        <button
        class='btn btn-default'
        data-loading-text='${btn_info.loading_text}'
        data-event-type='${btn_info.event_type}'
        data-btn-text='${btn_info.text}'>
            ${btn_info.text}
        </button>
      `).appendTo(this.toolbar);
        };

        append_btn({
            loading_text: 'Adding...',
            event_type: 'add_row',
            text: 'Add Row'
        });

        append_btn({
            loading_text: 'Removing...',
            event_type: 'remove_row',
            text: 'Remove Row'
        });

        this.buttons = this.toolbar.find('.btn');
        this.buttons.attr('title',
            'Not available while there is an active filter');
        this.buttons.tooltip();
        this.buttons.tooltip({
            show: { delay: 300 }
        });
        this.buttons.tooltip({
            hide: { delay: 100, 'duration': 0 }
        });
        this.buttons.tooltip('disable');

        this.full_screen_btn = null;
        this.bind_toolbar_events();
    }

    bind_toolbar_events() {
        this.buttons.off('click');
        this.buttons.click((e) => {
            let clicked = $(e.target);
            if (clicked.hasClass('disabled')) {
                return;
            }
            if (this.in_progress_btn) {
                alert(`
          Adding/removing row is not available yet because the
          previous operation is still in progress.
        `);
            }
            this.in_progress_btn = clicked;
            clicked.text(clicked.attr('data-loading-text'));
            clicked.addClass('disabled');
            this.send({ 'type': clicked.attr('data-event-type') });
        });
        if (!this.full_screen_btn) {
            return;
        }
        this.full_screen_btn.off('click');
        this.full_screen_btn.click((e) => {
            this.$el_wrapper = this.$el.parent();
            this.$el_wrapper.height(this.$el_wrapper.height());
            this.$el.detach();
            var modal_options = {
                body: this.$el[0],
                show: false
            };
            if (IPython && IPython.keyboard_manager) {
                modal_options.keyboard_manager = IPython.keyboard_manager;
            }
        });
    }

    /**
     * Create the grid portion of the widget, which is an instance of
     * SlickGrid, plus automatically created filter controls based on the
     * type of data in the columns of the DataFrame provided by the user.
     */
    initialize_slick_grid() {

        if (!this.grid_elem) {
            this.grid_elem = $("<div class='q-grid'>").appendTo(this.$el);
        }

        // create the table
        var df_json = JSON.parse(this.model.get('_df_json'));
        var columns = this.model.get('_columns');
        this.data_view = this.create_data_view(df_json.data);
        this.grid_options = this.model.get('grid_options');
        this.index_col_name = this.model.get("_index_col_name");
        this.row_styles = this.model.get("_row_styles");

        this.columns = [];
        this.index_columns = [];
        this.filters = {};
        this.filter_list = [];
        this.date_formats = {};
        this.last_vp = null;
        this.sort_in_progress = false;
        this.sort_indicator = null;
        this.resizing_column = false;
        this.ignore_selection_changed = false;
        this.vp_response_expected = false;
        this.next_viewport_msg = null;

        $.datepicker.setDefaults({
            gotoCurrent: true,
            dateFormat: $.datepicker.ISO_8601,
            constrainInput: false,
            "prevText": "",
            "nextText": ""
        });

        var sorted_columns = Object.values(columns).sort(
            (a, b) => a.position - b.position
        );

        for (let cur_column of sorted_columns) {
            if (cur_column.name == this.index_col_name) {
                continue;
            }

            var type_info = {};
            var slick_column = cur_column;
            Object.assign(slick_column, type_info);

            if (cur_column.width == null) {
                delete slick_column.width;
            }

            if (cur_column.maxWidth == null) {
                delete slick_column.maxWidth;
            }

            if (cur_column.is_index) {
                if (cur_column.first_index) {
                    slick_column.cssClass += ' first-idx-col';
                }
                if (cur_column.last_index) {
                    slick_column.cssClass += ' last-idx-col';
                }

                slick_column.name = cur_column.index_display_text;
                slick_column.level = cur_column.level;

                if (this.grid_options.boldIndex) {
                    slick_column.cssClass += ' idx-col';
                }

                this.index_columns.push(slick_column);
                continue;
            }

            if (cur_column.editable == false) {
                slick_column.editor = null;
            }

            this.columns.push(slick_column);
        }

        if (this.index_columns.length > 0) {
            this.columns = this.index_columns.concat(this.columns);
        }

        this.slick_grid = new Slick.Grid(
            this.grid_elem,
            this.data_view,
            this.columns,
            this.grid_options
        );

        // Pass this to Slick.AutoColumnSize because the plugin needs to call
        // this.makeSureResizingAColumnDoesntTriggerHeaderClickEvent() after
        // setting column widths which breaks some events of our grid.
        var auto_column_size_plugin = new Slick.AutoColumnSize(this);
        this.slick_grid.registerPlugin(auto_column_size_plugin);
        this.grid_elem.data('slickgrid', this.slick_grid);

        if (this.grid_options.forceFitColumns) {
            this.grid_elem.addClass('force-fit-columns');
        }

        if (this.grid_options.highlightSelectedCell) {
            this.grid_elem.addClass('highlight-selected-cell');
        }

        // compare to false since we still want to show row
        // selection if this option is excluded entirely
        if (this.grid_options.highlightSelectedRow != false) {
            this.grid_elem.addClass('highlight-selected-row');
        }

        setTimeout(() => {
            this.slick_grid.init();
            this.update_size();
        }, 1);

        this.slick_grid.setSelectionModel(new Slick.RowSelectionModel());
        this.slick_grid.setCellCssStyles("grouping", this.row_styles);
        this.slick_grid.render();

        this.update_size();


        var render_header_cell = (e, args) => {
            dtype_button.render_dtype_button(args.column, $(args.node), this)

            var header_click = (event) => {
                if (this.resizing_column) {
                    return;
                }

                if ('is_index' in args.column) {
                    // dont notify when clicking on index button
                } else {
                    var msg = {
                        'type': 'bam_rename_column',
                        'field': args.column.field
                    };
                    this.send(msg);
                }
            }
            $(args.node).on('click', header_click)
        };
        this.slick_grid.onHeaderCellRendered.subscribe(render_header_cell);

        // Force the grid to re-render the column headers so the
        // onHeaderCellRendered event is triggered.
        this.slick_grid.setColumns(this.slick_grid.getColumns());

        $(window).resize(() => {
            this.slick_grid.resizeCanvas();
        });

        this.slick_grid.setSortColumns([]);

        // needed later:
        this.grid_header = this.$el.find('.slick-header-columns');

        this.slick_grid.onViewportChanged.subscribe((e) => {
            if (this.viewport_timeout) {
                clearTimeout(this.viewport_timeout);
            }
            this.viewport_timeout = setTimeout(() => {
                this.last_vp = this.slick_grid.getViewport();
                var cur_range = this.model.get('_viewport_range');

                if (this.last_vp.top != cur_range[0] || this.last_vp.bottom != cur_range[1]) {
                    var msg = {
                        'type': 'change_viewport',
                        'top': this.last_vp.top,
                        'bottom': this.last_vp.bottom
                    };
                    if (this.vp_response_expected) {
                        this.next_viewport_msg = msg
                    } else {
                        this.vp_response_expected = true;
                        this.send(msg);
                    }
                }
                this.viewport_timeout = null;
            }, 100);
        });

        // set up callbacks
        let editable_rows = this.model.get('_editable_rows');
        if (editable_rows && Object.keys(editable_rows).length > 0) {
            this.slick_grid.onBeforeEditCell.subscribe((e, args) => {
                editable_rows = this.model.get('_editable_rows');
                return editable_rows[args.item[this.index_col_name]]
            });
        }

        this.slick_grid.onCellChange.subscribe((e, args) => {
            var column = this.columns[args.cell].name;
            var data_item = this.slick_grid.getDataItem(args.row);
            var msg = {
                'row_index': data_item.row_index, 'column': column,
                'unfiltered_index': data_item[this.index_col_name],
                'value': args.item[column], 'type': 'edit_cell'
            };
            this.send(msg);
        });

        this.slick_grid.onSelectedRowsChanged.subscribe((e, args) => {
            if (!this.ignore_selection_changed) {
                var msg = { 'rows': args.rows, 'type': 'change_selection' };
                this.send(msg);
            }
        });

        setTimeout(() => {
            this.$el.closest('.output_wrapper')
                .find('.out_prompt_overlay,.output_collapsed').click(() => {
                    setTimeout(() => {
                        this.slick_grid.resizeCanvas();
                    }, 1);
                });

            this.makeSureResizingAColumnDoesntTriggerHeaderClickEvent();
        }, 1);
    }

    makeSureResizingAColumnDoesntTriggerHeaderClickEvent() {
        setTimeout(() => {
            this.resize_handles = this.grid_header.find('.slick-resizable-handle');
            this.resize_handles.mousedown((e) => {
                this.resizing_column = true;
            });
            $(document).on('mouseup', () => {
                // wait for the column header click handler to run before
                // setting the resizing_column flag back to false
                setTimeout(() => {
                    this.resizing_column = false;
                }, 1);
            });
        }, 1);
    }

    processPhosphorMessage(msg) {
        super.processPhosphorMessage(msg)
        switch (msg.type) {
            case 'resize':
            case 'after-show':
                if (this.slick_grid) {
                    this.slick_grid.resizeCanvas();
                }
                break;
        }
    }

    has_active_filter() {
        for (var i = 0; i < this.filter_list.length; i++) {
            var cur_filter = this.filter_list[i];
            if (cur_filter.is_active()) {
                return true;
            }
        }
        return false;
    }

    /**
     * Main entry point for drawing the widget,
     * including toolbar buttons if necessary.
     */
    create_data_view(df) {
        let df_range = this.df_range = this.model.get("_df_range");
        let df_length = this.df_length = this.model.get("_row_count");
        return {
            getLength: () => {
                return df_length;
            },
            getItem: (i) => {
                if (i >= df_range[0] && i < df_range[1]) {
                    var row = df[i - df_range[0]] || {};
                    row.row_index = i;
                    return row;
                } else {
                    return { row_index: i };
                }
            }
        };
    }

    set_data_view(data_view) {
        this.data_view = data_view;
        this.slick_grid.setData(data_view);
    }

    /**
     * Handle messages from the BamGridWidget.
     */
    handle_msg(msg) {
        if (msg.type == "bam_live_code_export") {
            this.updateLiveCodeExport(msg.code_export, msg.initial_user_code)
        } else if (msg.type == "bam_refresh_grid") {
            this.slick_grid.resizeCanvas()
        } else if (msg.type === 'draw_table') {
            this.initialize_slick_grid();
        } else if (msg.type == 'show_error') {
            alert(msg.error_msg);
            if (msg.triggered_by == 'add_row' ||
                msg.triggered_by == 'remove_row') {
                this.reset_in_progress_button();
            }
        } else if (msg.type == 'update_data_view') {
            if (this.buttons) {
                if (this.has_active_filter()) {
                    this.buttons.addClass('disabled');
                    this.buttons.tooltip('enable');
                } else if (this.buttons.hasClass('disabled')) {
                    this.buttons.removeClass('disabled');
                    this.buttons.tooltip('disable');
                }
            }
            if (this.update_timeout) {
                clearTimeout(this.update_timeout);
            }
            this.update_timeout = setTimeout(() => {
                var df_json = JSON.parse(this.model.get('_df_json'));
                this.row_styles = this.model.get("_row_styles");
                this.multi_index = this.model.get("_multi_index");
                var data_view = this.create_data_view(df_json.data);

                if (msg.triggered_by === 'change_viewport') {
                    if (this.next_viewport_msg) {
                        this.send(this.next_viewport_msg);
                        this.next_viewport_msg = null;
                        return;
                    } else {
                        this.vp_response_expected = false;
                    }
                }

                if (msg.triggered_by == 'change_sort' && this.sort_indicator) {
                    var asc = this.model.get('_sort_ascending');
                    this.sort_indicator.removeClass(
                        'fa-spinner fa-spin fa-sort-asc fa-sort-desc'
                    );
                    var fa_class = asc ? 'fa-sort-asc' : 'fa-sort-desc';
                    this.sort_indicator.addClass(fa_class);
                    this.sort_in_progress = false;
                }

                let top_row = null;
                if (msg.triggered_by === 'remove_row') {
                    top_row = this.slick_grid.getViewport().top;
                }

                this.set_data_view(data_view);

                var skip_grouping = false;
                if (this.multi_index) {
                    for (var i = 1; i < this.filter_list.length; i++) {
                        var cur_filter = this.filter_list[i];
                        if (cur_filter.is_active()) {
                            skip_grouping = true;
                        }
                    }
                }

                if (skip_grouping) {
                    this.slick_grid.removeCellCssStyles("grouping");
                } else {
                    this.slick_grid.setCellCssStyles("grouping", this.row_styles);
                }

                this.slick_grid.render();

                if ((msg.triggered_by == 'add_row' ||
                    msg.triggered_by == 'remove_row') && !this.has_active_filter()) {
                    this.update_size();
                }
                this.update_timeout = null;
                this.reset_in_progress_button();
                if (top_row) {
                    this.slick_grid.scrollRowIntoView(top_row);
                } else if (msg.triggered_by === 'add_row') {
                    this.slick_grid.scrollRowIntoView(msg.scroll_to_row);
                    this.slick_grid.setSelectedRows([msg.scroll_to_row]);
                } else if (msg.triggered_by === 'change_viewport' &&
                    this.last_vp.bottom >= this.df_length) {
                    this.slick_grid.scrollRowIntoView(this.last_vp.bottom);
                }

                var selected_rows = this.slick_grid.getSelectedRows().filter((row) => {
                    return row < Math.min(this.df_length, this.df_range[1]);
                });
                this.send({
                    'rows': selected_rows,
                    'type': 'change_selection'
                });
            }, 100);
        } else if (msg.type == 'change_grid_option') {
            var opt_name = msg.option_name;
            var opt_val = msg.option_value;
            if (this.slick_grid.getOptions()[opt_name] != opt_val) {
                this.slick_grid.setOptions({ [opt_name]: opt_val });
                this.slick_grid.resizeCanvas();
            }
        } else if (msg.type == 'change_show_toolbar') {
            this.initialize_toolbar();
        } else if (msg.col_info) {
            var filter = this.filters[msg.col_info.name];
            filter.handle_msg(msg);
        }
    }

    reset_in_progress_button() {
        if (this.in_progress_btn) {
            this.in_progress_btn.removeClass('disabled');
            this.in_progress_btn.text(
                this.in_progress_btn.attr('data-btn-text')
            );
            this.in_progress_btn = null;
        }
    }

    /**
     * Update the size of the dataframe.
     */
    update_size() {
        var row_height = this.grid_options.rowHeight;
        var min_visible = 'minVisibleRows' in this.grid_options ?
            this.grid_options.minVisibleRows : 8;
        var max_visible = 'maxVisibleRows' in this.grid_options ?
            this.grid_options.maxVisibleRows : 15;

        var min_height = row_height * min_visible;
        // add 2 to maxVisibleRows to account for the header row and padding
        var max_height = 'height' in this.grid_options ? this.grid_options.height :
            row_height * (max_visible + 2);
        var grid_height = max_height;
        var total_row_height = (this.data_view.getLength() + 1) * row_height + 1;
        if (total_row_height <= max_height) {
            grid_height = Math.max(min_height, total_row_height);
            this.grid_elem.addClass('hide-scrollbar');
        } else {
            this.grid_elem.removeClass('hide-scrollbar');
        }
        this.grid_elem.height(grid_height);
        this.slick_grid.render();
        this.slick_grid.resizeCanvas();
    }
}

module.exports = {
    BamGridModel: BamGridModel,
    BamGridView: BamGridView,
};
